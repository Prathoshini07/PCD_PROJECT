#if !defined(TOKEN_H)
#define TOKEN_H

#include <string>
#include <iostream>

enum TokenType
{
    // Reserved Keywords
    VOID_TOKEN, MAIN_TOKEN, INT_TOKEN, FLOAT_TOKEN, DOUBLE_TOKEN, CHAR_TOKEN,
    SHORT_TOKEN, LONG_TOKEN, SIGNED_TOKEN, UNSIGNED_TOKEN, STRUCT_TOKEN, UNION_TOKEN,
    ENUM_TOKEN, STATIC_TOKEN, AUTO_TOKEN, REGISTER_TOKEN, VOLATILE_TOKEN, CONST_TOKEN,
    EXTERN_TOKEN, INLINE_TOKEN, TYPEDEF_TOKEN, RETURN_TOKEN, BREAK_TOKEN, CONTINUE_TOKEN,
    GOTO_TOKEN, SWITCH_TOKEN, CASE_TOKEN, DEFAULT_TOKEN, DO_TOKEN, WHILE_TOKEN, FOR_TOKEN,
    IF_TOKEN, ELSE_TOKEN, SIZEOF_TOKEN, STATIC_ASSERT_TOKEN, THREAD_LOCAL_TOKEN,
    _ALIGNAS_TOKEN, _ALIGNOF_TOKEN, _ATOMIC_TOKEN, _BOOL_TOKEN, _COMPLEX_TOKEN,
    _GENERIC_TOKEN, _IMAGINARY_TOKEN, _NORETURN_TOKEN, _STATIC_ASSERT_TOKEN,
    _THREAD_LOCAL_TOKEN,ELLIPSIS_TOKEN, COUT_TOKEN, ENDL_TOKEN, RESERVED_COUNT,
    TERNARY_QUESTION_TOKEN, TERNARY_COLON_TOKEN,LESS_THAN_TOKEN, LESS_THAN_EQUALS_TOKEN,
    GREATER_THAN_TOKEN, GREATER_THAN_EQUALS_TOKEN, 

    // Logical Operators
    LOGICAL_AND_TOKEN, LOGICAL_OR_TOKEN, LOGICAL_NOT_TOKEN, NOT_EQUALS_TOKEN,
    EQUALITY_TOKEN, LESS_TOKEN, LESS_EQUAL_TOKEN, GREATER_TOKEN, GREATER_EQUAL_TOKEN,

    // Arithmetic Operators
    PLUS_TOKEN, MINUS_TOKEN, MULTIPLY_TOKEN, DIVIDE_TOKEN, MODULUS_TOKEN,
    INCREMENT_TOKEN, DECREMENT_TOKEN,MULTIPLY_BY_TOKEN, DIVIDE_BY_TOKEN,

    // Assignment Operators
    ASSIGNMENT_TOKEN, PLUS_EQUALS_TOKEN, MINUS_EQUALS_TOKEN, MULTIPLY_EQUALS_TOKEN,
    DIVIDE_EQUALS_TOKEN, MODULUS_EQUALS_TOKEN, AND_EQUALS_TOKEN, OR_EQUALS_TOKEN,
    XOR_EQUALS_TOKEN, LEFT_SHIFT_EQUALS_TOKEN, RIGHT_SHIFT_EQUALS_TOKEN,EQUAL_TOKEN,NOT_EQUAL_TOKEN,

    // Bitwise Operators
    BITWISE_AND_TOKEN, BITWISE_OR_TOKEN, BITWISE_XOR_TOKEN, BITWISE_NOT_TOKEN,
    LEFT_SHIFT_TOKEN, RIGHT_SHIFT_TOKEN,OR_TOKEN, AND_TOKEN, XOR_TOKEN,OR_WORD_TOKEN,AND_WORD_TOKEN,NOT_TOKEN,

    // Delimiters & Punctuation
    SEMICOLON_TOKEN, COMMA_TOKEN, DOT_TOKEN, ARROW_TOKEN, COLON_TOKEN, QUESTION_MARK_TOKEN,
    LEFT_PAREN_TOKEN, RIGHT_PAREN_TOKEN, LEFT_BRACE_TOKEN, RIGHT_BRACE_TOKEN,
    LEFT_BRACKET_TOKEN, RIGHT_BRACKET_TOKEN,

    // Stream Operators (C++ specific)
    INSERTION_TOKEN, EXTRACTION_TOKEN,

    // Literals
    IDENTIFIER_TOKEN, INTEGER_TOKEN, FLOAT_LITERAL_TOKEN, DOUBLE_LITERAL_TOKEN,
    HEX_LITERAL_TOKEN, OCTAL_LITERAL_TOKEN, EXPONENTIAL_LITERAL_TOKEN,
    CHAR_LITERAL_TOKEN, STRING_LITERAL_TOKEN,

    // Format Specifiers (C-style `printf` and `scanf`)
    FORMAT_INT_TOKEN, FORMAT_CHAR_TOKEN, FORMAT_STRING_TOKEN, FORMAT_DOUBLE_TOKEN,
    FORMAT_FLOAT_TOKEN, FORMAT_HEX_TOKEN, FORMAT_OCTAL_TOKEN, FORMAT_UNSIGNED_TOKEN,
    FORMAT_LONG_TOKEN, FORMAT_LONG_LONG_TOKEN, FORMAT_SHORT_TOKEN, FORMAT_WCHAR_TOKEN,
    FORMAT_WSTRING_TOKEN, FORMAT_WCHAR_T_TOKEN, FORMAT_WINT_T_TOKEN,

    // Preprocessor Directives
    HASH_TOKEN, INCLUDE_TOKEN, DEFINE_TOKEN, UNDEF_TOKEN, IFDEF_TOKEN, IFNDEF_TOKEN,
    ENDIF_TOKEN, PRAGMA_TOKEN, LINE_TOKEN,

    // Escape Sequences
    ESCAPE_NEWLINE_TOKEN, ESCAPE_TAB_TOKEN, ESCAPE_BACKSLASH_TOKEN, ESCAPE_QUOTE_TOKEN,
    ESCAPE_DOUBLE_QUOTE_TOKEN, ESCAPE_BACKSPACE_TOKEN, ESCAPE_CARRIAGE_RETURN_TOKEN,

    // Comments
    SINGLE_LINE_COMMENT_TOKEN, MULTI_LINE_COMMENT_TOKEN,

    // End of File & Errors
    BAD_TOKEN, ENDFILE_TOKEN
};

class Token
{
private:
    TokenType type;
    std::string lexeme;
    std::string filename;
    int line;

public:
    static const std::string &GetTokenTypeName(TokenType type);

    Token();
    Token(TokenType type, const std::string &lexeme);
    Token(TokenType type, const std::string& lexeme, std::string fileName, int line);
    ~Token();

    const std::string &GetTokenTypeName() const;
    TokenType GetTokenType() const;
    std::string GetLexeme() const;

    // if this lexeme is one of the reserved words, then assign it that token
    void CheckReserved();

    friend std::ostream &operator<<(std::ostream &out, const Token &tc);
};

#endif // TOKEN_H